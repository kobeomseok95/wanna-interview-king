### Q. Transaction에 대해 설명해주세요.
- 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위
- 한 트랜잭션 안에서 어떤 작업이 예외가 발생할 경우 이전 상태로 복귀시키는 `rollback`, 성공적으로 수행했을 경우 `commit`하여 **데이터의 일관성을 보장**해야한다.
### Q. Transaction의 4가지 특성에 대해 설명해주세요.
- **Atomicity (원자성)**
    - 한 트랜잭션 내의 작업들이 모두 성공하여 **commit** 시키거나, 하나라도 실패할 경우 **rollback**하여 원 상태로 복구해야함
- **Consistency (일관성)**
    - 데이터베이스의 **상태가 트랜잭션 이후에도 일관적인 상태**여야 하는 성질
        - 유저 테이블의 경우 email을 `unique`, `not null` 로 설정
        - 유저를 가입시킬 때, email이 null이면 안되고, email을 update할 때도 null이어도 안됨
        - 즉, 유저 email을 고유하고 null이 안되는 경우로 설정했다면 이 설정이 트랜잭션과 상관 없이 지켜져야 함
- **Isolation (독립성)**
    - 하나의 트랜잭션은 다른 트랜잭션의 영향을 받지 않고 **독립적**이어야 한다는 성질
- **Durability (지속성)**
    - 트랜잭션을 수행했을 경우 시스템 에러가 발생해도 데이터베이스에 대한 기록은 영구적이어야한다.
### Q. Transaction Isolation Level에 대해 설명해주세요.
    
> **Isolation Level (고립 수준)**
> 
> - 여러 트랜잭션이 **동시**에 처리될 때, 다른 트랜잭션에서 변경하거나 조회하는 **데이터를 볼 수 있는지**에 대한 수준
> - 각 레벨이 올라갈 수록 안정성이 높아지지만 동시성이 떨어진다.
1. **READ UNCOMMITTED**
    1. 삽입의 경우
    2. Commit, Rollback에 **관계 없이 데이터를 볼 수 있는** 고립 레벨
    3. 예를 들어, 500번째 유저가 생성되었고, 다른 트랜잭션에서 유저를 조회할 경우 500번째 유저가 조회된다.
    4. 만약 이 500번째 유저가 rollback될 경우, 다시 유저를 조회하면 500번째 유저가 보이지 않아 정합성이 깨지는 레벨, 이를 `Dirty Read` 현상이라 한다.
2. **READ COMMITTED**
    1. 수정의 경우
    2. 최종적으로 어떤 트랜잭션이 **Commit한 데이터만 볼 수 있는** 고립 레벨
    3. 예를 들어, 500번째 유저의 이름을 Update하는 트랜잭션이 발생하는 동안 다른 트랜잭션에서 유저를 조회할 때 Update되기 전의 데이터를 InnoDB 기준으로 Undo 영역에서 조회한다.
    4. 하지만, Update 쿼리가 Commit된 후 다른 트랜잭션이 또 유저를 조회하면 500번째 유저의 이름이 변경되어 있는 상황이 발생하는데, 이를 `Non-Repeatable Read` 현상이라 한다.
3. **REPEATABLE READ**
    1. UNDO 영역에 백업된 이전 데이터를 이용해 **동시에 접근한 트랜잭션 내에서는 동일한 결과를 보장**받게 하는 고립 레벨
    2. MySQL 5.7 버전의 InnoDB Default 설정
4. **SERIALIZABLE**
    1. 한 트랜잭션에서 읽고 쓰는 레코드를 **접근하지 못하도록** 하는 고립 레벨
### Q. Index가 무엇인가요?**
- 데이터베이스에서 **조회 및 검색을 더 빠르게** 할 수 있는 방법 혹은 자료구조
- **컬럼의 값**과 해당 레코드가 저장된 **주소**를 key-value 형태 저장시킴
### Q. Index를 왜 쓰나요? 그리고 동작 방식과 주의해야될 사항도 말해주세요.
- 사용 이유
    - 데이터가 많을 경우 기본적으로 모든 데이터를 순회하게 되는데, 이를 보다 효율적으로 찾기 위해서 사용
- 동작 방식
    - B+Tree를 기준으로 root node부터 찾으려는 데이터의 row 주소값이 있는 leaf node까지 순차적으로 탐색합니다.
    - 이 후 주소값을 통해 조회할 `select`절의 **컬럼에 해당하는 데이터**들을 가져옵니다.
- 주의 사항
    - **중복되는 값이 적은 컬럼**을 인덱스로 설정해야 합니다.
        - 이유는, 인덱스도 하나의 자원이기 때문에 인덱스 컬럼의 값이 변경되면 모든 인덱스도 변경되기 때문입니다.
